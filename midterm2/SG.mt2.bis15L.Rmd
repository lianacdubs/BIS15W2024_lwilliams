---
title: "sg2_midterm"
author: "Liana Williams"
date: "2024-02-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Review when to use each plot type

#Hw 8 to... (double check with profs answers )

## HW 8

## Load the libraries
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(janitor)
``` 

## Install `here`
The package `here` is a nice option for keeping directories clear when loading files. I will demonstrate below and let you decide if it is something you want to use.  
```{r}
#install.packages("here")
```

## Data
For this homework, we will use a data set compiled by the Office of Environment and Heritage in New South Whales, Australia. It contains the enterococci counts in water samples obtained from Sydney beaches as part of the Beachwatch Water Quality Program. Enterococci are bacteria common in the intestines of mammals; they are rarely present in clean water. So, enterococci values are a measurement of pollution. `cfu` stands for colony forming units and measures the number of viable bacteria in a sample [cfu](https://en.wikipedia.org/wiki/Colony-forming_unit).   

This homework loosely follows the tutorial of [R Ladies Sydney](https://rladiessydney.org/). If you get stuck, check it out!  

1. Start by loading the data `sydneybeaches`. Do some exploratory analysis to get an idea of the data structure.
```{r}
sydneybeaches <- read_csv("data/sydneybeaches.csv")
```

If you want to try `here`, first notice the output when you load the `here` library. It gives you information on the current working directory. You can then use it to easily and intuitively load files.
```{r}
library(here)
```

The quotes show the folder structure from the root directory.
```{r}
sydneybeaches <-read_csv(here("homework", "data", "sydneybeaches.csv")) %>% clean_names()
```

2. Are these data "tidy" per the definitions of the tidyverse? How do you know? Are they in wide or long format?

_The data appear to be tidy. Each variable has its own column, each observation has its own row, and each cell has its own value. Because the sites are repeated based on their observation date, the data are in long format._

```{r}
names(sydneybeaches)
```

3. We are only interested in the variables site, date, and enterococci_cfu_100ml. Make a new object focused on these variables only. Name the object `sydneybeaches_long`
```{r}
sydneybeaches_long <- sydneybeaches %>% 
  select(site, date, enterococci_cfu_100ml)
sydneybeaches_long
```

4. Pivot the data such that the dates are column names and each beach only appears once (wide format). Name the object `sydneybeaches_wide`
```{r}
sydneybeaches_wide <- sydneybeaches_long %>% 
  pivot_wider(names_from=date,
              values_from=enterococci_cfu_100ml)
sydneybeaches_wide
```

5. Pivot the data back so that the dates are data and not column names.
```{r}
sydneybeaches_wide %>% 
  pivot_longer(-site,
               names_to="date",
               values_to="enterococci_cfu_100ml"
               )
```

6. We haven't dealt much with dates yet, but separate the date into columns day, month, and year. Do this on the `sydneybeaches_long` data.
```{r}
sydneybeaches_long %>% 
  separate(date, into=c("day", "month", "year"), sep="/")
```

7. What is the average `enterococci_cfu_100ml` by year for each beach. Think about which data you will use- long or wide.
```{r}
mean_entero <- 
  sydneybeaches_long %>% 
  separate(date, into=c("day", "month", "year"), sep="/") %>% 
  group_by(site, year) %>% 
  summarize(mean_enterococci_cfu_100ml=mean(enterococci_cfu_100ml, na.rm=T))
mean_entero
```

8. Make the output from question 7 easier to read by pivoting it to wide format.
```{r}
mean_entero %>% 
  pivot_wider(names_from=site,
              values_from=mean_enterococci_cfu_100ml)
```

9. What was the most polluted beach in 2013?
```{r}
mean_entero %>% 
  pivot_wider(names_from=site,
              values_from=mean_enterococci_cfu_100ml) %>% 
  filter(year==2013) %>% 
  pivot_longer(-year,
               names_to = "site",
               values_to = "mean_enterococci_cfu_100ml") %>% 
  arrange(desc(mean_enterococci_cfu_100ml))
```

```{r}
mean_entero %>% 
  pivot_wider(names_from=site,
              values_from=mean_enterococci_cfu_100ml) %>% 
  filter(year==2013) %>% 
  pivot_longer(-year,
               names_to = "site",
               values_to = "mean_enterococci_cfu_100ml") %>% 
  slice_max(mean_enterococci_cfu_100ml, n=3)
```

## HW 9 
## Load the libraries
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(janitor)
library(here)
library(naniar)
``` 

For this homework, we will take a departure from biological data and use data about California colleges. These data are a subset of the national college scorecard (https://collegescorecard.ed.gov/data/). Load the `ca_college_data.csv` as a new object called `colleges`.
```{r}
colleges <- readr::read_csv("data/ca_college_data.csv") %>% janitor::clean_names()
```

The variables are a bit hard to decipher, here is a key:  

INSTNM: Institution name  
CITY: California city  
STABBR: Location state  
ZIP: Zip code  
ADM_RATE: Admission rate  
SAT_AVG: SAT average score  
PCIP26: Percentage of degrees awarded in Biological And Biomedical Sciences  
COSTT4_A: Annual cost of attendance  
C150_4_POOLED: 4-year completion rate  
PFTFTUG1_EF: Percentage of undergraduate students who are first-time, full-time degree/certificate-seeking undergraduate students  

1. Use your preferred function(s) to have a look at the data and get an idea of its structure. Make sure you summarize NA's and determine whether or not the data are tidy. You may also consider dealing with any naming issues.
```{r}
glimpse(colleges)
```

```{r}
names(colleges)
```

```{r}
naniar::miss_var_summary(colleges)
```

2. Which cities in California have the highest number of colleges?
```{r}
colleges %>% 
  count(city) %>% 
  arrange(desc(n))
```

3. Based on your answer to #2, make a plot that shows the number of colleges in the top 10 cities.
```{r}
colleges %>% 
  count(city) %>% 
  top_n(10, n) %>% 
  ggplot(aes(x=reorder(city,n), y=n))+
  geom_col()+
  coord_flip()
```

4. The column `COSTT4_A` is the annual cost of each institution. Which city has the highest average cost? Where is it located?
```{r}
colleges %>% 
  group_by(city) %>% 
  summarize(mean_cost_yr=mean(costt4_a, na.rm=TRUE),
            total=n()) %>% 
  arrange(desc(mean_cost_yr))
```

5. Based on your answer to #4, make a plot that compares the cost of the individual colleges in the most expensive city. Bonus! Add UC Davis here to see how it compares :>).
```{r}
colleges %>% 
  filter(instnm== "University of California-Davis" | city=="Claremont" & costt4_a!="NA") %>% 
  ggplot(aes(x=instnm, y=costt4_a)) + 
  geom_col()+
  coord_flip()
```

6. The column `ADM_RATE` is the admissions rate by college and `C150_4_POOLED` is the four-year completion rate. Use a scatterplot to show the relationship between these two variables. What do you think this means?
```{r}
colleges %>% 
  ggplot(aes(x=adm_rate, y=c150_4_pooled))+
  geom_point(na.rm=T)+
  geom_smooth(method=lm, se=F, na.rm=T)
```

7. Is there a relationship between cost and four-year completion rate? (You don't need to do the stats, just produce a plot). What do you think this means?
```{r}
colleges %>% 
  ggplot(aes(x=costt4_a, y=c150_4_pooled))+
  geom_point(na.rm=T)+
  geom_smooth(method=lm, se=F, na.rm=T)
```

8. The column titled `INSTNM` is the institution name. We are only interested in the University of California colleges. Make a new data frame that is restricted to UC institutions. You can remove `Hastings College of Law` and `UC San Francisco` as we are only interested in undergraduate institutions.
```{r}
univ_calif <- colleges %>% 
  filter_all(any_vars(str_detect(., pattern = "University of California")))
univ_calif
```

Remove `Hastings College of Law` and `UC San Francisco` and store the final data frame as a new object `univ_calif_final`.
```{r}
univ_calif_final <- univ_calif %>% 
  filter(city!="San Francisco")
univ_calif_final
```

Use `separate()` to separate institution name into two new columns "UNIV" and "CAMPUS".
```{r}
univ_calif_final <- univ_calif_final %>% 
  separate(instnm, c("univ", "campus"), sep="-")
univ_calif_final
```

9. The column `ADM_RATE` is the admissions rate by campus. Which UC has the lowest and highest admissions rates? Produce a numerical summary and an appropriate plot.
```{r}
univ_calif_final %>% 
  select(campus, adm_rate) %>% 
  arrange(adm_rate)
```

```{r}
univ_calif_final %>% 
  ggplot(aes(x=reorder(campus, adm_rate), y=adm_rate))+
  geom_col()+
  coord_flip()
```

10. If you wanted to get a degree in biological or biomedical sciences, which campus confers the majority of these degrees? Produce a numerical summary and an appropriate plot.
```{r}
univ_calif_final %>% 
  select(campus, pcip26) %>% 
  arrange(pcip26)
```

```{r}
univ_calif_final %>% 
  ggplot(aes(x=reorder(campus, pcip26), y=pcip26))+
  geom_col()
```

#Lab 8 to...


#Lab 8.1 
Let's say we were interested in how body mass varied by island. It is reasonable to assume that the islands are different, so maybe the penguins are as well.
```{r}
penguins %>% 
  group_by(island) %>% 
  summarize(mean_body_mass_g=mean(body_mass_g, na.rm=T)) # remember to remove those NA's!
```

What if we are interested in the number of observations (penguins) by species and island?
```{r}
penguins %>% 
  group_by(island, species) %>% 
  summarize(n_penguins=n(), .groups = 'keep')
```

##Count : shows the number of observations
```{r}
penguins %>% 
  count(island, species)
```
Note: **tabyl** will also produce counts

##Across()
```{r}
penguins %>%
  summarize(across(c(species, island, sex), n_distinct))
```

All variables that include "bill"...all of the other dplyr operators also work.
```{r}
penguins %>%
  summarise(across(starts_with("bill"), n_distinct))
```
Summarize across all variables 
```{r}
penguins %>%
  summarise_all(n_distinct)
```

#Lab 8.2 
Here is a new one for you using the `purrr` package. This will give you a quick summary of the number of NA's in each variable.
```{r}
life_history %>% 
  map_df(~ sum(is.na(.))) #tell where all the NAs ; R doesn't see -999 as NAs 
```

## `naniar`
`naniar` is a package that is built to manage NA's. Many of the functions it performs can also be performed using tidyverse functions, but it does provide some interesting alternatives. 

`miss_var_summary` provides a clean summary of NA's across the data frame.
```{r}
naniar::miss_var_summary(life_history) #use naniar package and get a missing variable summary of the life_history
#pct is the percent missing
```

Note: sometimes NAs can be represented as different numbers. 
Let's use `mutate()` and `na_if()` to replace 0's with NA's in `max_life`.
```{r}
life_history_no_nas <- life_history_no_nas %>% 
  mutate(max_life=na_if(max_life, 0))
```

We can also use `miss_var_summary` with `group_by()`. This helps us better evaluate where NA's are in the data.
```{r}
life_history %>%
  group_by(order) %>%
  #select(order, wean_mass) %>% 
  miss_var_summary(order=T)
```

`naniar` also has a nice replace function which will allow you to precisely control which values you want replaced with NA's in each variable.
```{r}
life_history %>% 
  replace_with_na(replace = list(newborn = "not measured", 
                                 weaning= -999, 
                                 wean_mass= -999, 
                                 afr= -999, 
                                 max_life= 0, 
                                 litter_size= -999, 
                                 gestation= -999, 
                                 mass= -999)) %>% 
miss_var_summary()
#makes replacement of NA's specific to a variable
```

You can also use naniar to replace a specific value (like -999) with NA across the entire data set.  
```{r}
life_history %>% #going back to the original data
  replace_with_na_all(condition = ~.x == -999)%>% 
miss_var_summary()
```

Finally, naniar has some built-in examples of common values or character strings used to represent NA's. The chunk below will use these built-in parameters to replace NA's across the entire data set.
```{r}
common_na_strings
```

```{r}
common_na_numbers
```

```{r}
life_history %>% #going back to the original data
  replace_with_na_all(condition = ~.x %in% c(common_na_strings, common_na_numbers)) %>% 
  mutate(newborn=na_if(newborn, "not measured"))
```

## Visualizing NAs
There is another package `visdat` that can be used to visualize the proportion of different classes of data, including missing data. But, it is limited by size.

## Dealing with NA's in advance
If you are sure that you know how NA's are treated in the data, then you can deal with them in advance using `na()` as part of the `readr` package.

#Alternative
```{r}
read_csv(file = "data/mammal_lifehistories_v3.csv", na = c("NA", " ", ".", "-999", "not measured")) %>% clean_names()
```

#Lab 9.1 
https://cran.r-project.org/web/packages/tidyr/vignettes/pivot.html
##Pivot data from wide to long.  
pivot_longer() "lengthens" data, increasing the number of rows and decreasing the number of columns.
```{r}
#pivot_longer() makes datasets LONGER by increasing
#^This command shifts data from wide to long
#The problem is that column names may represent values of a variable! 
```
Rules:  
+ `pivot_longer`(cols, names_to, values_to)
+ `cols` - Columns to pivot to longer format
+ `names_to` - Name of the new column; it will contain the column names of gathered columns as values
+ `values_to` - Name of the new column; it will contain the data stored in the values of gathered columns

***REVIEW 9.1 EXAMPLE***
***LAB10 Warmup***
Simulated malaria data #Load the data 
```{r}
malaria <- read_csv("data/malaria.csv") %>% clean_names()
```

```{r}
names(malaria)
```

```{r}
head(malaria) #age range is specified for those cases because column names contain information. 
```

#rdt refers to rapid diagnostic test 
##Data tidy
Pivot longer
```{r}
malaria_long <- malaria %>% 
  pivot_longer(cols=starts_with("malaria_rdt"),
               names_to = "age_class",
               values_to = "cases") %>% 
  select(newid, data_date, submitted_date, location_name, province, district, age_class, cases)
```
^There is still work to make these cleaner like age_class is ugly. 

Which district had the highest number of cases on July 30, 2020?
```{r}
malaria_long %>% 
  filter(data_date=="2020-07-30") %>% 
  group_by(district) %>% 
  summarize(tot_cases=sum(cases, na.rm=T)) %>% 
  arrange(-tot_cases) #this is another way to do descending order. 
```



##Tidy Data 
REVIEW CHAPTER 12 
[chapter 12 of the data science text](https://r4ds.had.co.nz/tidy-data.html)
`Tidy` data follows three conventions:   
(1) each variable has its own column  
(2) each observation has its own row  
(3) each value has its own cell  

## Example 3: more than one variable in a column name
Example: exp1rep1

#Lab 9.2 
##pivot data from long to wide 
pivot_wider() "widens" data, increasing the number of columns and decreasing the number of rows.
```{r}
#column namess are the problem. there is (more than one) value per cell and the columns represent values.
```

You use `pivot_wider()` when you have an observation scattered across multiple rows. In the example below, `cases` and `population` represent variable names not observations.  

Rules:  
+ `pivot_wider`(names_from, values_from)  
+ `names_from` - Values in the `names_from` column will become new column names  
+ `values_from` - Cell values will be taken from the `values_from` column  

```{r}
tb_data %>% 
  pivot_wider(names_from = "key", #the observations under key will become new columns; key have two names cases and population
              values_from = "value") #the values under value will be moved to the new columns
```

Example Pivot_Wider
```{r}
gene_exp <- read_csv("data/gene_exp.csv")
gene_exp
```
#there are more than one variable in a column (treatment and control)
```{r}
gene_exp %>% 
  pivot_wider(names_from = "type", #has two values in the type column which are  treatment and control
              values_from = "L4_values")
```

`separate()` needs to know which column you want to split, the names of the new columns, and what to look for in terms of breaks in the data.
```{r}
heartrate2 %>% 
  separate(patient, into= c("patient", "sex"), sep = "_") #separate patient into two new variables patient and sex
```

`unite()` is the opposite of separate(). Its syntax is straightforward. You only need to give a new column name and then list the columns to combine with a separation character. 
```{r}
heartrate3 %>% 
  unite(patient_sex, "patient", "sex", sep=" ") #not super common but, could be a way to present the data
```

#Lab 10.1 
 [ggplot2 cheatsheet](https://posit.co/resources/cheatsheets/)  ; this is apart of the tidyverse
 
In short, **plot= data + geom_ + aesthetics**.  

#think of geom as type like box plot, dot plot etc. 
#aesthetics can be like what the x and y axis are etc. 
```{r}
ggplot(data=iris, #specify the data
       mapping=aes(x=Species, y=Petal.Length))+ #map the aesthetics
  geom_boxplot() #add the plot type
```

## Data Types 
+ `discrete` quantitative data that only contains integers
+ `continuous` quantitative data that can take any numerical value
+ `categorical` qualitative data that can take on a limited number of values

```{r}
ggplot(data=homerange, #specify the data
       mapping=aes(x=log10.mass, y=log10.hra))+ #map the aesthetics
  geom_point() #add the plot type; this is a scatterplot
#as mass goes up the homerange increases 
```

`geom_jitter()` is similar to `geom_point()` but it helps with over plotting by adding some random noise to the data and separating some of the individual points.
#geom_jitter() can be be used for scatter plot
```{r}
ggplot(data=homerange, mapping=aes(x=log10.mass, y=log10.hra))+
  geom_jitter() #adds some random noise
#if the dataset is super big could be a problem called overplotting. 
```

To add a regression (best of fit) line, we just add another layer.
```{r}
ggplot(data=homerange, mapping=aes(x=log10.mass, y=log10.hra))+
  geom_point()+
  geom_smooth(method=lm, se=T) #add a regression line
```
#There is a warning if leave geom_point() empty ^. if you don't put na.rm=t; by default ggplot will pull these out

### Bar Plot: `geom_bar()`
The simplest type of bar plot counts the number of observations in a categorical variable.

Also notice that we can use pipes! The `mapping=` function is implied by `aes` and so is often left out. 
```{r}
homerange %>% 
  ggplot(aes(x=trophic.guild)) + #there is only one variable in this plot. noteL the x= is not needed. 
  geom_bar() #good for counts
```
#You cannot make a bar plot with continuous data. 

### Bar Plot: `geom_col()`
Unlike `geom_bar()`, `geom_col()` allows us to specify an x-axis and a y-axis.
```{r}
homerange %>% 
  filter(family=="salmonidae") %>%
  select(common.name, log10.mass) %>% 
  ggplot(aes(y=common.name, x=log10.mass))+ #notice the switch in x and y
  geom_col()
```

Make a bar plot that shows the masses of the top 10 smallest mammals.
```{r}
homerange %>% 
  filter(class=="mammalia") %>% 
  top_n(-10, log10.mass) %>% 
  ggplot(aes(x=common.name, y=log10.mass))+
  geom_col()+
coord_flip() #add a + at the end of each layer
```

coord_flip() this switches the x and y axis

#Lab 10.2 
***Good Examples***
Boxplots help us visualize a range of values. So, on the x-axis we typically have something categorical and the y-axis is the range.

`geom_boxplot()` is the geom type for a standard box plot. The center line in each box represents the median, not the mean.
```{r}
homerange %>% 
  ggplot(aes(x = class, y = log10.mass)) +
  geom_boxplot() #shows the same information as the code chunk above. 
#Note: the line in the middle is the median. 
```

#Lab 11.1 

#Lab 11.2 