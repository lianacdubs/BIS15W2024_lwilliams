---
title: "study_guide_mt1"
output: html_document
date: "2024-01-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Note: This study guide doesn't include the HW! 
#Lab 1 
class repository "datascibiol" (https://github.com/jmledford3115/datascibiol)**Star**
[R cheatsheets](https://posit.co/resources/cheatsheets/)
-GitHub is a file storage and management site used by programmers. The software Git uses version control. 
--Programmers upload code to **repositories(folders)** and make it publicly avail.
-GitHub desktop is an easy way to manage GitHub repository. 
## Clone Your Repository  
In GitHub desktop, you will see your personal repository as an option under `clone repository`. Clone your repository to the desktop. Once you have done this any changes you make to files will be recorded and easily uploaded. Do not move this folder from your desktop. 
## Copy the Class Repository
You do this by navigating to the repository then going to the small green code button at top right. Click on the code button then go to Download ZIP.  
-Terms to Define: 
1. `Commit` takes a snapshot of your current progress.    
2. `Pull` this is the same as download.     
3. `Push` this is the same as upload.  
Clicking the `Commit to master` button in the bottom left corner means that you are recording a snapshot of your edits locally. Once this is done, you need to upload your changes to GitHub. This is done by clicking `Push origin`. Once you have pushed your changes you can double check by looking at your repository on github.com.    
## R and RStudio
R is an open source, **scripting** language. 
--therefore, write instructiongs used by the computer to complete an operation.
---no typos, punctuation errors, errant spaces, or other types of mistakes. 
RStudio is a GUI that is used to interact with R. 
-**working directory** is the location on your computer where you are currently working. (Place where R studio will save all your work.)
```{r}
getwd() #if not in correct wd then, Session>Set Working Directory>Choose Directory>Desktop>
```
In R '>' is where commands are entered. 
##Arithmetic
Order of operations applies. No need for = 
-Making a **vector** aka string of values to store an an object then we can perform stats on the object. 
--'Objects' in R are a way in which we can store data or operations. 
## RMarkdown Basics 
Document read in R Studio. 
**Why use R Markdown**. 
Transparency in experimental methodology, observation, collection of data and analytical methods.
Public availability and re-usability of scientific data.
Public accessibility and transparency of scientific communication.
Using web-based tools to facilitate scientific collaboration.
###Titles and Text
'#' is used for tittles 
-The more hashtags = smaller font
--Text with no '#' is smallest and not bold. 
_italics_
**bold**
line break is indiacated. 
by two spaces. 
###Links
'[]' for name of the webpage and '()' for website address. 
For emails you need to include 'malito:' in parenthesis. [Liana Williams](malito:lcwilliams@ucdavis.edu)
###Code chunks 
 "Insert>R" at the top of the page. On a Mac, the shortcut is `option+command+i`.  
###Knit 
make an html file "builds a file" 
##To get help with a command 
?**command name**

To install.packages(_insertnameofpackage_)  
once installed then, library(_nameofpackage_)
#Lab2 
Assign a value to object 'x'. The '<-' symbol is read as 'gets'. In this case, x gets 42. Make sure that you are in the environment panel and you should see the value associated with 'x'. On a mac, you can push `option` and `-` to automatically generate the gets symbol.  
##2.1 Objects, Nomenclature, Types of Data, Missing Data
-Don't assign names to objects that are the same as functions in R 
*There are five frequently used `classes` of data: 1. numeric, 2. integer(L notates an integer), 3. character(""), 4. logical(TRUE or FALSE), 5. complex.*
To find out what type of data you are working with, use the `class()` function.
You can use the `is()` and `as()` functions to clarify or specify a type of data.
```{r}
is.integer(my_numeric) #is my_numeric an integer?
```

```{r}
my_integer <- 
  as.integer(my_numeric) #create a new object specified as an integer
```

```{r}
is.integer(my_integer) #is my_numeric an integer?
```
NA values are used to designate missing data. `is.na` or `anyNA` are useful functions when dealing with NAs in data.
-Tells TRUE or FALSE 
```{r}
mean(new_vector, na.rm=T) #na.rm removes the NA values in the vector
```
##2.2 
Data Structures: include vectors, lists, matrices, dataframes, and factors 
**vectors** create vectors using the 'c' command which means concatenate. 
*A vector is a list of variables, and the simplest data structure in R*  
--We can **identify vector elements** with the [], you only get the values, not the logical evaluation of the entire vector.
**Data Matrices**: series of stacked vectors, similar to a data table. 
Name the columns using `colnames()` with the vector region.
Name the rows using `rownames()` with the vector titles.
`cbind()` adds columns.
Adding a colon `:` selects the specified elements in a column.  

row on the left column on the right? 
- if you want the entire column do something like [ ,2] which pulls out all of coumn 2 (look vertically?)


#Lab 3 
For the warm up when we were making the matrix. How do you know it by nrow =5 and byrow = F? What do those functions do?
- Byrow if you want to fill in horizontal (T) 
-bycolmn  if fill top to bottom. (F)
--can you review when you would do colmeans (vertical)vs rowmeans(horizontal)???
Vectors can be organized into a new data structure called **data frames**. 
Data frames are similar to a spreadsheet. It can store data of many different classes. 

matrix only have one class. 
data frame can have multiple classes each column can have a different class
##3.1 
Ex: Combine our three vectors to create a data frame with the function `data.frame()`.  
Data Frames show the class of data.
'names()' gives the column names of the vector  
'dim()' gives the dimensions
'str()' gives the structure; this gives the structure where each variable(column) is NOW a row, an observation is what goes in a cell.
`dbl` means that the value is a type of numeric [double precision floating point](http://uc-r.github.io/integer_double/).  
We can change the name in a dataframe by (new_name=Old_name) the data in the dataframe is overwritten so it now appears as new_name for the variable. 
## Accessing Data Frame Columns and Rows 
The same methods of selecting elements in vectors and data matrices apply to data frames. We use `[]`. We have two positions where the first applies to the rows, and the second to the columns.  
Ex: hbirds[1,] means first row; if [,3] then, 3rd column.
We can also select values in an entire column using the `$` sign.  
We can add a new bird's data with the `rbind()` function, known as row bind. It will bind our new vector to our data frame row-wise.
## Writing Data to File  
.csv is comma separated values (data type that can be imported into R)

##3.2 
1. Import .csv files as data frames using `read_csv()`.  
##Load the Data 
Since we are using the tidyverse, we open the file using `read_csv()`. `readr` is included in the tidyverse set of packages. We specify the package and function with the `::` symbol. This becomes important if you have multiple packages loaded that contain functions with the same name. 
A **factor** has discrete levels (there is a max. amount). 
## Summary functions
We can summarize our data frame with the`summary()` function.  
`glimpse()` is another useful summary function.  
`nrow()` gives the numbers of rows.  
`ncol` gives the number of columns.  
`names` gives the column names.  
`head()` prints the first n rows of the data frame.  
`tail()` prinst the last n rows of the data frame.  
`table()` is useful when you have a limited number of categorical variables. It produces fast counts of the number of observations in a variable. We will come back to this later...   
We can also 'View()' in the environment panel  
## Filter
Filter is a way of pulling out observations that meet specific criteria in a variable. (More in lab 4).   
Observations are in a cell of the spreadsheet  

##Lab 4    
##4.1   
Note: Data frames are more detailed than a data matrix.  
**read** (is the command) to IMPORT csv  
**write** (is the command) to EXPORT csv
## We will be working on tidyverse
### Once installed then do library("tidyverss")  
##Load the data  
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
##readr is ecplicit of the package we are using. the code would work without this. 
**Every variable(vertical) is own column**  
**Every observation(horizontal) in own row**  
**Each (cell) has one value**  
## refer to the warm up for practice of lab 3 using tables, na function, and $ finction
## dplyr
The first package that we will use that is part of the tidyverse is `dplyr`. `dplyr` is used to transform data frames by extracting, rearranging, and summarizing data such that they are focused on a question of interest. Good for large data. The two functions we will use most are `select()` and `filter()`.  
Takes a data frame and then, chops it up how you want then, makes it tidy.  
## `select()`
Select allows you to pull out columns aka variables of interest from a dataframe. To do this, just add the names of the columns to the `select()` command. The order in which you add them, will determine the order in which they appear in the output.  
**Select doesn't allow us to extract observations from within the dataframe** 

We are only interested in lakeid and scalelength.
```{r}
select(fish, "lakeid", "scalelength") #(name of data frame which is an object, variable1 of interst, variable2 of interest)
```
In the above example the data frame is chopped up vertically. It shows column for lakeid and column for scalelength.  
### if you reverse the order of variable it changes the order in the table
###you can also create an object by some_name <- _inserttheselectfunction_
To add a range of columns use `start_col:end_col`.
```{r}
select(fish, fish_id:length)
```

The **-** operator is useful in select. It allows us to select everything except the specified variables.
```{r}
select(fish, -"fish_id", -"annnumber", -"length", -"radii_length_mm")
#Pulls out all the variables that are not the ones listed. another explanation is excludes the ones listed (doesn't show those in data)
```
'contains()'  
```{r}
select(fish, contains("length"))
#look into the fish data and remove everything that has to do with length
```

When columns are sequentially named, `starts_with()` makes selecting columns easier.
```{r}
select(fish, starts_with("radii"))
#pull out all the variables that start with the name radii
```

#These are the most common! 
Options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
2. contains() = Select columns that contain a character string  
3. matches() = Select columns that match a regular expression  (regex)
4. one_of() = Select columns names that are from a group of names  

## You can select columns based on class of data
```{r}
select_if(fish, is.numeric)
```
To select all columns that are *not* a class of data, you need to add a `~`.
```{r}
select_if(fish, ~!is.numeric(.)) 
#look into fish and pull things that are not numerics. 
#~ is all cells ! is DONT pull out the ones that are not numeric 
# ! = not 
```

#The practice 
##shows how to load the data, access structure, find NAs, names of the columns, rename the columns (new name= old name), select to build a new dataframe to include variables of interest, using the - operator to exclude variables, select columns using contain, select all columns that are of class)  
### Other features include jantor (which is a package) + running it, tolower(), toupper(), and code to remove blanks    

#Lab 4.2  
**The `filter()` function allows us to extract data that meet specific criteria.**  
## `filter()`
Unlike `select()`, `filter()` allows us to extract data that meet specific criteria within a variable. Let's say that we are interested only in the fish that occur in lake "AL". We can use `filter()` to extract these observations.
###Filter allows us to search through a dataframe and pull out observations (rows) of interest. Can be used to explore data of interest and reshape dataframes to focus on certain questions  
`filter()` allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  
Using the `!` operator allows for the exclusion of specific observations  
## Using `filter()` with multiple observations  
Filtering multiple values within the same variable requires the `%in%`
Alternatively, you can use `between` if you are looking for a range of specific values.
You can also extract observations "near" a certain value but you need to specify a tolerance.  
## Practice
1. Filter the `fish` data to include the samples from lake "BO".
2. Filter the data to include all lakes except "AR".
3. Filter the fish data to include all fish with a scalelength within 0.25 of
4. Filter the fish data to include fish with a scalelength between 2 and 4.  
## Using `filter()` on multiple conditions
You can also use `filter()` to extract data based on multiple conditions. 
& and | operators  
Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met. 


**A little note on Pipe**
 %>% "and then"
Pipe allows for a series of sequential functions to be applied to an object. 
```{r}
wakeup(self) %>% 
  put_on("clothes") %>% 
  eat("breakfast") %>% 
  go(to = "work")
```

```{r}
#If performing the steps multiple times then assign it to an object. 
morning_routine <- wakeup(self) %>% 
  put_on("clothes") %>% 
  eat("breakfast") %>% 
  go(to = "work")
```

The tidyverse is a series of packages that allows you to more easily perform the steps of data science. 
#Lab 5 introduction 
1. What is the association between the tidyverse, dplyr, select, and filter?  
#The main package is tidyverse within that is the package dplyr and select and filter are functions in it. 
2. Describe how `select ()` can be used to transform data frames.  
#Select allows you to select columns(variables) of interest (works vertically)
3. Describe how `filter ()` can be used to transform data frames. 
#filter can be used to filter out specific values (works horizontal in rows)
#Lab 5.1 
The janitor package cleans up the data (e.g. makes all capital letters lowercase)
#Factors show how many categories there are in a variable. They are a data type to use when you know a certain variable will have repeated values. So when you take the levels of a factor, you are shown all the different levels (values). 
```{r}
# Looking at tropic_guild (variable) it has two values (herbivor or carnivore)
```
#You can use 'filter()' on multiple conditions.
#The `|` operator is inclusive 

Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met.  
```{r}
#In this case, we filter out the fish with a length over 400 AND a scale length over 11 OR a radii length over 8.

#filter(fish, length > 400, (scalelength > 11 | radii_length_mm > 8))
```

#Lab 5.2 
Pipes %>%  allow us to combine 'select()', 'filter()' and other functions efficently. Pipes feed the output from one function into the input of another function. 

On MAC: shift,command,m
^^ How to make a pipe!  

'arrange()' command is like a SORT command in excel. The default is in ascending order.   
To sort in decreasing order, wrap the variable name in `desc()`.  

`mutate()`  
Mutate allows us to create a new column from existing columns in a data frame.  

`mutate_all()`
This last function is super helpful when cleaning data.  

Here is an example that changes all entries to lowercase (if present).  

Using the across function we can specify individual columns.  

With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  
-use if_else to allow to use the 'mutate' function but, not have the entire column affected in the same way. this is similar to find and replace. 


#Lab 6.1  
The characteristics of 'tidy' data are...
Each column is a variable  
Each row is an observation  
Each cell is a value  

For mutate we won't have to create a new object!  
For cleannames it only works for column names! 


Practice on mutate(), mutate_all(), across function, if_else()

#Lab 6.2  
The 'janitor' package has the function 'tabyl()' which produces counts and percentages.
**refer to HW for the code for this section**  

#Lab 7.1  
Tips for Midterm: 
Read the abstract to understand the data. If a piece of code doesn't run put a hashtag in front of it. 
group_by works for categorial variables and it is a way to produce summaries for observations that share an element of interest  
the functions 'summarize' and 'group_by' work well together.  
'count' works when you are only interested in the number of observations (like a combination of groupby and summarize)  
the new package is skimr 
Code involving select(), filter(), mutate()
## `summarize()`
`summarize()` will produce summary statistics for a given variable in a data frame.  
Shortcut to run only a couple lines of code is #Note: shortcut highlight command return  

**n_distinct is a function needed for the exam**

`n_distinct()` is a very handy way of cleanly presenting the number of distinct observations.  
There are many other useful summary statistics, depending on your needs: sd(), min(), max(), median(), sum(), n() (returns the length of a column), first() (returns first value in a column), last() (returns last value in a column) and n_distinct() (number of distinct values in a column).  
#Lab 7.2 
More groupby and summarize practice. 
`count()` is an easy way of determining how many observations you have within a column. It acts like a combination of `group_by()` and `n()`.  
There is a function in dplyr called `across()` which is designed to work across multiple variables.