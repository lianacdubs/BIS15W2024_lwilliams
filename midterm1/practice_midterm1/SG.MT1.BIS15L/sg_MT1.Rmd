---
title: "study_guide_mt1"
output: html_document
date: "2024-01-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Note: This study guide doesn't include the HW code just describes it. The README file has all the learning objectives. 
#Lab 1 
**What is the difference between R and RStudio? What is GitHub and why is it useful to programmers?**  
R is the script. 
R studio is the GUI

class repository "datascibiol" (https://github.com/jmledford3115/datascibiol)**Star**
[R cheatsheets](https://posit.co/resources/cheatsheets/)
-GitHub is a file storage and management site used by programmers. The software Git uses version control! 
--Programmers upload code to **repositories(folders)** and make it publicly avail.
-GitHub desktop is an easy way to manage GitHub repository. 
## Clone Your Repository  
In GitHub desktop, you will see your personal repository as an option under `clone repository`. Clone your repository to the desktop. Once you have done this any changes you make to files will be recorded and easily uploaded. Do not move this folder from your desktop. 
## Copy the Class Repository
You do this by navigating to the repository then going to the small green code button at top right. Click on the code button then go to Download ZIP.  
-Terms to Define: 
1. `Commit` takes a snapshot of your current progress.    
2. `Pull` this is the same as download.     
3. `Push` this is the same as upload.  
Clicking the `Commit to master` button in the bottom left corner means that you are recording a snapshot of your edits locally. Once this is done, you need to upload your changes to GitHub. This is done by clicking `Push origin`. Once you have pushed your changes you can double check by looking at your repository on github.com.    
## R and RStudio
R is an open source, **scripting** language. 
--therefore, write instructiongs used by the computer to complete an operation.
---no typos, punctuation errors, errant spaces, or other types of mistakes. 
RStudio is a GUI that is used to interact with R. 
-**working directory** is the location on your computer where you are currently working. (Place where R studio will save all your work.)
```{r}
getwd() #if not in correct wd then, Session>Set Working Directory>Choose Directory>Desktop>*insert folder here*
```
In R '>' is where commands are entered. 
##Arithmetic
Order of operations applies. No need for = 
```{r}
4*12
```

-Making a **vector** aka string of values to store an an object then we can perform stats on the object. 
```{r}
x <- c(4, 6, 8)
#mean(x)
#median(x)
#sd(x)
```

--'Objects' in R are a way in which we can store data or operations.
In the example above X is an object! 
## RMarkdown Basics 
Open Up a new markdown document: **File>New File>R Markdown** 
Document read in R Studio. 
**Why use R Markdown**. 
Transparency in experimental methodology, observation, collection of data and analytical methods.
Public availability and re-usability of scientific data.
Public accessibility and transparency of scientific communication.
Using web-based tools to facilitate scientific collaboration.
###Titles and Text
'#' is used for tittles 
-The more hashtags = smaller font
--Text with no '#' is smallest and not bold. 
_italics_
**bold**
line break is indiacated. 
by two spaces. 
###Links
'[]' for name of the webpage and '()' for website address. 
For emails you need to include 'malito:' in parenthesis. [Liana Williams](malito:lcwilliams@ucdavis.edu)
###Code chunks 
 "Insert>R" at the top of the page. On a Mac, the shortcut is `option+command+i`.  
###Knit 
make an html file "builds a file" 
##To get help with a command 
?**command name**

To install.packages(_insertnameofpackage_)  
once installed then, library(_nameofpackage_)

#HW 1 
arithmetic + vectors + calculate statistic for a vector

Get help with any command you can type a '?' in front of the command of interest
```{r}
?mean
```

#Lab2 
Assign a value to object 'x'. The '<-' symbol is read as 'gets'. In this case, x gets 42. Make sure that you are in the environment panel and you should see the value associated with 'x'. On a mac, you can push `option` and `-` to automatically generate the gets symbol.  
```{r}
treatment <- 36
control <- 38
```

```{r}
my_exp <- sum(treatment, control)
my_exp #make a new object that does the sum of the two objects.
```

##2.1 Objects, Nomenclature, Types of Data, Missing Data
-Don't assign names to objects that are the same as functions in R
-Use arithmetric to calculate...
*There are five frequently used `classes` of data: 1. numeric, 2. integer(L notates an integer), 3. character(""), 4. logical(TRUE or FALSE), 5. complex.*
To find out what type of data you are working with, use the `class()` function.
You can use the `is()` and `as()` functions to clarify or specify a type of data.
```{r}
is.integer(my_numeric) #is my_numeric an integer?; returns false
```

```{r}
my_integer <- 
  as.integer(my_numeric) #create a new object specified as an integer
```

```{r}
is.integer(my_integer) #is my_numeric an integer? #true
```
NA values are used to designate missing data. `is.na` or `anyNA` are useful functions when dealing with NAs in data.
-Tells TRUE or FALSE 
```{r}
mean(new_vector, na.rm=T) #na.rm removes the NA values in the vector
```

```{r}
new_varia <- NA #assigns
is.na(new_varia) #check for NAs
anyNA(new_varia)
```
Even if you have a lot of values in a vector even with one NA in the vector it won't calculate the result.

##2.2 
Data Structures: include vectors, lists, matrices, dataframes, and factors 
**vectors** create vectors using the 'c' command which means concatenate. 
*A vector is a list of variables, and the simplest data structure in R*  

A numeric vector.
```{r}
my_vector <- c(10, 20, 30)
```

A character vector. Characters always have quotes and may be referred to as "strings".
```{r}
days_of_the_week <- c("Monday", "Tuesday", "Wednesday", "Thrusday", "Friday", "Saturday", "Sunday")
```

A convenient trick for creating a vector is to generate a sequence of numbers.
```{r}
my_vector_sequence <- c(1:100)
my_vector_sequence
```

--We can **identify vector elements** with the [], you only get the values, not the logical evaluation of the entire vector.
**Data Matrices**: series of stacked vectors, similar to a data table. 

use operators such as <, >, ==, <==, etc.

Name the columns using `colnames()` with the vector region.
Name the rows using `rownames()` with the vector titles.
`cbind()` adds columns.
Adding a colon `:` selects the specified elements in a column.  

row on the left(first) column on the right(second)
- if you want the entire column do something like [ ,2] which pulls out all of coumn 2 (look vertically?)
Adding a colon `:` selects the specified elements in a column.  

#HW 2
vector: is a data structure in R. It is essentially multiple variables of the same type grouped together under a single piece of memory. 
-Build a data matrix. 

#Lab 3 
Lab 3 intro makes a data matrix. 
For the warm up when we were making the matrix. How do you know it by nrow =5 and byrow = F? What do those functions do?
- Byrow if you want to fill in horizontal (T) 
-bycolmn  if fill top to bottom. (F)
--can you review when you would do colmeans (vertical)vs rowmeans(horizontal)???
Vectors can be organized into a new data structure called **data frames**. 
Data frames are similar to a spreadsheet. It can store data of many different classes. 

matrix only have one class. 
data frame can have multiple classes each column can have a different class
##3.1 
Ex: Combine our three vectors to create a data frame with the function `data.frame()`.  
Data Frames show the class of data.
'names()' gives the column names of the vector  
'dim()' gives the dimensions
'str()' gives the structure; this gives the structure where each variable(column) is NOW a row, an observation is what goes in a cell.
`dbl` means that the value is a type of numeric [double precision floating point](http://uc-r.github.io/integer_double/).  
We can change the name in a dataframe by (new_name=Old_name) the data in the dataframe is overwritten so it now appears as new_name for the variable. 
```{r}
hbirds <- data.frame(sex=Sex, length=Length, weight_g=Weight)
#the word to the left of the equal sign is the new word and the word to the right of the equal sign is the old word. This will overwrite the data we had. This is similar to clean_names
```

## Accessing Data Frame Columns and Rows 
The same methods of selecting elements in vectors and data matrices apply to data frames. We use `[]`. We have two positions where the first applies to the rows, and the second to the columns.  
Ex: hbirds[1,] means first row; if [,3] then, 3rd column.
We can also select values in an **entire column** using the `$` sign.
We can also add more data with $ 
```{r}
hbirds$neighborhood <- c("lakewood", "brentwood", "lakewood", "scenic Heights")
hbirds
```

## Adding Rows 
```{r}
hbirds<- rbind(hbirds, new_bird)
hbirds
```

We can add a new bird's data with the `rbind()` function, known as row bind. It will bind our new vector to our data frame row-wise. 

## Writing Data to File  
.csv is comma separated values (data type that can be imported into R)
```{r}
write.csv(hbirds, "hbirds_data.csv", row.names = FALSE)
```


##3.2 
1. Import .csv files as data frames using `read_csv()`.  
##Load the Data 
Since we are using the tidyverse, we open the file using `read_csv()`. `readr` is included in the tidyverse set of packages.
```{r}
hot_springs <- read_csv("hsprings_data.csv")
#or an alternative is if its in another folder. 
fish <- read_csv("data/Gaeta_etal_CLC_data.csv")
#note data/ will open the folder called data. alternatively but not practice would be to draf the file in the main lab3 folder
```

We specify the package and function with the `::` symbol. This becomes important if you have multiple packages loaded that contain functions with the same name. 
A **factor** has discrete levels (there is a max. amount). 
## Summary functions
We can summarize our data frame with the`summary()` function.  
`glimpse()` is another useful summary function. 
'str()' get an idea of the data structure
'class()' 
`nrow()` gives the numbers of rows.
`ncol` gives the number of columns.  
`names` gives the column names.  
`head()` prints the first n rows of the data frame.  
`tail()` prinst the last n rows of the data frame.  
`table()` is useful when you have a limited number of categorical variables. It produces fast counts of the number of observations in a variable. We will come back to this later...   
We can also 'View()' in the environment panel
```{r}
hot_springs$scientist <- as.factor(hot_springs$scientist)
#replace scientist in the hotsprings dataframe but make it into a factor
```
#a factor has discrete levels (there is a max amount)
```{r}
levels(hot_springs$scientist) #tells how many different factors you have in a variable.
```

'summary()' you can summarize the data frame. It gives basic stats. The values have to be numeric. 

## Filter
Filter is a way of pulling out observations that meet specific criteria in a variable. (More in lab 4).   
Observations are in a cell of the spreadsheet  
```{r}

```

#HW 3 
msleep <- msleep # this object now appears in the environment panel.
dim()
checks NAs 
names() tells a list of column names 
make two dataframes with parameters.
mean calculation
```{r}
large_mean <- mean(large$bodywt)
large_mean
```


##Lab 4    
Warmup has good stuff
What is the mean body mass for all individuals in the `penguins` dataset?

```{r}
mean(penguins$body_mass_g, na.rm=T) 
#before adding na.rm=T the output is NA so, you have to do this command to get mean. 
```

##4.1   
Note: Data frames are more detailed than a data matrix.  
**read** (is the command) to IMPORT csv  
**write** (is the command) to EXPORT csv
## We will be working on tidyverse
### Once installed then do library("tidyverss")  
##Load the data  
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
##readr is ecplicit of the package we are using. the code would work without this. 
## Tidyverse 
is an "opinionated" collection of packages that make workflow in R easier. (clean, organize, manage data )
**Every variable(vertical) is own column**  
**Every observation(horizontal) in own row**  
**Each (cell) has one value**  
## refer to the warm up for practice of lab 3 using tables, na function, and $ finction
## dplyr
The first package that we will use that is part of the tidyverse is `dplyr`. `dplyr` is used to transform data frames by extracting, rearranging, and summarizing data such that they are focused on a question of interest. Good for large data. The two functions we will use most are `select()` and `filter()`.  
Takes a data frame and then, chops it up how you want then, makes it tidy.  
## `select()`
Select allows you to pull out columns aka variables of interest from a dataframe. To do this, just add the names of the columns to the `select()` command. The order in which you add them, will determine the order in which they appear in the output.  
**Select doesn't allow us to extract observations from within the dataframe** 

We are only interested in lakeid and scalelength.
```{r}
select(fish, "lakeid", "scalelength") #(name of data frame which is an object, variable1 of interst, variable2 of interest)
```
In the above example the data frame is chopped up vertically. It shows column for lakeid and column for scalelength.  
### if you reverse the order of variable it changes the order in the table
###you can also create an object by some_name <- _inserttheselectfunction_
To add a range of columns use `start_col:end_col`.
```{r}
select(fish, fish_id:length)
```

The **-** operator is useful in select. It allows us to select everything except the specified variables.
```{r}
select(fish, -"fish_id", -"annnumber", -"length", -"radii_length_mm")
#Pulls out all the variables that are not the ones listed. another explanation is excludes the ones listed (doesn't show those in data)
```
'contains()'  
```{r}
select(fish, contains("length"))
#look into the fish data and remove everything that has to do with length
```

When columns are sequentially named, `starts_with()` makes selecting columns easier.
```{r}
select(fish, starts_with("radii"))
#pull out all the variables that start with the name radii
```

#These are the most common! 
Options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
```{r}
select(fish, ends_with("id")) 
#ends with id shows lakeid and fish_id
```

2. contains() = Select columns that contain a character string 

Select the columns that include "mass" as part of the name.  
```{r}
select(mammals_new, contains("mass"))
```

3. matches() = Select columns that match a regular expression  (regex)
4. one_of() = Select columns names that are from a group of names  

## You can select columns based on class of data
```{r}
select_if(fish, is.numeric)
```
To select all columns that are *not* a class of data, you need to add a `~`.
```{r}
select_if(fish, ~!is.numeric(.)) 
#look into fish and pull things that are not numerics. 
#~ is all cells ! is DONT pull out the ones that are not numeric 
# ! = not 
```

#The practice 
##shows how to load the data, access structure, find NAs, names of the columns, rename the columns (new name= old name), select to build a new dataframe to include variables of interest, using the - operator to exclude variables, select columns using contain, select all columns that are of class)  
### Other features include jantor (which is a package) + running it, tolower(), toupper(), and code to remove blanks 
When naming columns, blank spaces are often added (don't do this, please). Here is a trick to remove these.  
```{r}
#select_all(mammals, ~str_replace(., " ", "_"))
```


#Lab 4.2  
'select()' allows use to extract columns of interest from a data frame. (Cannot extract observations from within the dataframe.)
**The `filter()` function allows us to extract data that meet specific criteria.**  
## `filter()`
Unlike `select()`, `filter()` allows us to extract data that meet specific criteria within a variable. Let's say that we are interested only in the fish that occur in lake "AL". We can use `filter()` to extract these observations.
###Filter allows us to search through a dataframe and pull out observations (rows) of interest. Can be used to explore data of interest and reshape dataframes to focus on certain questions 
```{r}
filter(fish, lakeid == "AL") #pull out 383 observations
#instead of lakeid you can do length>=300
```
`filter()` allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  
Using the `!` operator allows for the exclusion of specific observations  
```{r}
not_AL <- filter(fish, lakeid != "AL") #! means not
```

## Using `filter()` with multiple observations  
Filtering multiple values within the same variable requires the `%in%`
```{r}
filter(fish, length %in% c(167, 175))
#within the variable length all those with length 167 or 175
#multiple values in the same variable %n% 
```

Alternatively, you can use `between` if you are looking for a range of specific values.
```{r}
filter(fish, between(scalelength, 2.5, 2.55))
```

You can also extract observations "near" a certain value but you need to specify a tolerance.  
```{r}
filter(fish, near(radii_length_mm, 2, tol = 0.2))
#look for radii length near two but within 0.2 of eachother 
#tol = tolerance
```

## Practice
1. Filter the `fish` data to include the samples from lake "BO".
```{r}
filter(fish, lakeid=="BO") #shows the BO samples
```

2. Filter the data to include all lakes except "AR".
```{r}
filter(fish, lakeid != "AR")
```

3. Filter the fish data to include all fish with a scalelength within 0.25 of 8 
```{r}
filter(fish, near(scalelength, 8, tol=0.25))
```

4. Filter the fish data to include fish with a scalelength between 2 and 4. 
```{r}
filter(fish, between(scalelength, 2, 4))
```

```{r}
#this also works 
filter(fish, scalelength %in% c(2,4))
```

## Using `filter()` on multiple conditions
```{r}
filter(fish, lakeid == "AL" & length > 350) #extract only the fish that have lakeid "AL" and length >350.
```

```{r}
filter(fish, lakeid == "AL" | length > 350) #Or doubles the variables
```
You can also use `filter()` to extract data based on multiple conditions. 
& and | operators  
Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met. 
```{r}
filter(fish, length > 400, (scalelength > 11 | radii_length_mm > 8))
#filter out the fish with a length greater than 400 and a scale length over 11 or a radiii length over 8
```



**A little note on Pipe**
 %>% "and then"
Pipe allows for a series of sequential functions to be applied to an object. 
```{r}
wakeup(self) %>% 
  put_on("clothes") %>% 
  eat("breakfast") %>% 
  go(to = "work")
```

```{r}
#If performing the steps multiple times then assign it to an object. 
morning_routine <- wakeup(self) %>% 
  put_on("clothes") %>% 
  eat("breakfast") %>% 
  go(to = "work")
```

#HW 4 
Change the class of the variable 'taxon' to a factor and display the levels. 
```{r}
#homerange is the dataset. 
homerange$taxon <- as.factor(homerange$taxon)
levels(homerange$taxon) 
```

Make a dataframe that is restricted to certain variables 
```{r}
taxa <- select(homerange, "taxon", "common.name", "class", "order", "family", "genus", "species")
taxa
```


The species in `homerange` are also classified into trophic guilds. How many species are represented in each trophic guild.**  
```{r}
table(homerange$trophic.guild)
```

**8. Do herbivores or carnivores have, on average, a larger `mean.hra.m2`? Remove any NAs from the data.**  
```{r}
mean(herbivores$mean.hra.m2, rm.na=T)
```


 Make a new dataframe `owls` that is limited to the mean mass, log10 mass, family, genus, and species of owls in the database. Which is the smallest owl? What is its common name? Do a little bit of searching online to see what you can learn about this species and provide a link below** 
```{r}
owls <- filter(homerange, order=="strigiformes")
owls_df <- select(owls, "mean.mass.g", "log10.mass", "family", "genus", "species")
filter(owls_df, mean.mass.g==61.32) #This finds the specific small owl
```

```{r}
#owls_datf <- select(filter(homerange, order=="strigiformes"), mean.mass.g, log10.preymass, family, genus, species)
#owls_datf
#all birds belongs to aves 
#all owls belong to one order called strigiformes
#To get the common name I added it to the comma list as common.name,
```
#^This was another methods that I found to work

**10. As measured by the data, which bird species has the largest homerange? Show all of your work, please. Look this species up online and tell me about it!**.  
```{r}
birds <- filter(homerange, taxon=="birds")
max(birds$mean.hra.m2)
```
```{r}
filter(birds, mean.hra.m2==2.41e+08)
```

The tidyverse is a series of packages that allows you to more easily perform the steps of data science. 
#Lab 5 introduction 
1. What is the association between the tidyverse, dplyr, select, and filter?  
#The main package is tidyverse within that is the package dplyr and select and filter are functions in it. 
2. Describe how `select ()` can be used to transform data frames.  
#Select allows you to select columns(variables) of interest (works vertically)
3. Describe how `filter ()` can be used to transform data frames. 
#filter can be used to filter out specific values (works horizontal in rows)
#Lab 5.1 
The janitor package cleans up the data (e.g. makes all capital letters lowercase)
#Factors show how many categories there are in a variable. They are a data type to use when you know a certain variable will have repeated values. So when you take the levels of a factor, you are shown all the different levels (values). 
```{r}
# Looking at tropic_guild (variable) it has two values (herbivor or carnivore)
```
#You can use 'filter()' on multiple conditions.
#The `|` operator is inclusive 

Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met.  
```{r}
#In this case, we filter out the fish with a length over 400 AND a scale length over 11 OR a radii length over 8.

#filter(fish, length > 400, (scalelength > 11 | radii_length_mm > 8))
```

##Practice 
1.  From the `mammals` data, filter all members of the family Bovidae with a mass greater than 450000.
```{r}
bovidae <- filter(mammals, mass>450000)
```

2. From the `mammals` data, build a data frame that compares `mass`, `gestation`, and `newborn` among the primate genera `Lophocebus`, `Erythrocebus`, and `Macaca`. Among these genera, which species has the smallest `newborn` mass?
```{r}
mammals2 <- select(mammals,"order", "genus", "mass", "gestation", "newborn")
mammals3 <- filter(mammals2, order=="Primates")
```

```{r}
mammals4 <- filter(mammals3, genus %in% c("Lophocebus", "Erythrocebus", "Macaca")) #click on the table and then sort it. 
```
#the problem with this way is it doesnt take the output of one command and feed it into another. 

#Lab 5.2 
Pipes %>%  allow us to combine 'select()', 'filter()' and other functions efficently. Pipes feed the output from one function into the input of another function. 

In this example, we use a pipe to select only `lakeid` and `scalelength` then filter that output only for lakes "AL". Notice that we only need to call the data one time.  
```{r}
select(fish, lakeid, scalelength) #pull variables of interest
```

```{r}
filter(fish, lakeid == "AL") #pull observations of interest
```

#shift,command,m makes the pipe. 

```{r}
fish %>% #shift,command,m makes the pipe. 
  select(lakeid, scalelength) %>% #the commands are then nested. use the fish data take out lakeid and scalelength
  filter(lakeid == "AL") #^use the output of the select function to filter out observations of interst.
```

Here we select family, genus, and species then filter for gestation greater than 15 months.
```{r}
mammals %>% 
  select(family, genus, species, gestation) %>% 
  filter(gestation>=15)
```

## Practice
1. We are interested in the fish from the lakes "AL" and "AR" with a radii length between 2 and 4. Extract this information from the `fish` data. Use pipes!  
```{r}
fish %>% #work with  fish data 
  select(lakeid, radii_length_mm) %>% #pull out variables of interest
  filter(lakeid == "AL" | lakeid=="AR") %>% #only these lakes 
  filter(between(radii_length_mm, 2, 4)) %>% #between 2 and 4 
  arrange(desc(radii_length_mm)) #sort for conciseness; arrange in decending order for radiilength 
```
On MAC: shift,command,m
^^ How to make a pipe!  

'arrange()' command is like a SORT command in excel. The default is in ascending order.   
To sort in decreasing order, wrap the variable name in `desc()`.  

```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(scalelength) #easy to find which has the smallest or largest (based on hw 4)
```

To sort in decreasing order, wrap the variable name in `desc()`.
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(desc(scalelength))
```

`arrange()` can be very helpful in combination with the other functions.
```{r}
fish %>% 
  select(lakeid, length, fish_id, scalelength) %>% 
  filter(lakeid=="AL") %>% 
  arrange(fish_id)
```

`mutate()`  
Mutate allows us to create a new column from existing columns in a data frame. 

Let's convert the length variable from cm to millimeters and create a new variable called length_mm.  
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
```

`mutate_all()`
This last function is super helpful when cleaning data.  

Here is an example that changes all entries to lowercase (if present).  
```{r}
mammals %>%
  mutate_all(tolower)
```

Using the across function we can specify individual columns.
```{r}
mammals %>% 
  mutate(across(c("order", "family"), tolower))
```

Here is an example that changes all entries to lowercase (if present).  

Using the across function we can specify individual columns.  

With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  
-use if_else to allow to use the 'mutate' function but, not have the entire column affected in the same way. this is similar to find and replace. 

Have a look at the data from mammals below. Notice that the values for newborn include `-999.00`. This is sometimes used as a placeholder for NA (but, is a really bad idea). We can use `if_else()` to replace `-999.00` with `NA`.  
```{r}
mammals %>% 
  select(genus, species, newborn) %>% 
  arrange(newborn)
```

```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
  arrange(newborn)
```


#Lab 6.1  
The characteristics of 'tidy' data are...
Each column is a variable  
Each row is an observation  
Each cell is a value  

For mutate we won't have to create a new object!  
For cleannames it only works for column names! 


Practice on mutate(), mutate_all(), across function, if_else(), Pipes (can attach clean_names to a pipe)

## `mutate()`  
Mutate allows us to create a new column from existing columns in a data frame. 
```{r}
fish %>% 
  mutate(length_mm = length*10) %>%  #new variable length in mm take the length and multiply by 10; it was originally cm
  select(fish_id, length, length_mm) #the variable in the table still says length
```
## `mutate_all()`
This cleans data! 
```{r}
mammals %>%
  mutate_all(tolower) #Taking all the observations and making them lower case
```

## `if_else()`
We will briefly introduce `if_else()` here because it allows us to use `mutate()` but not have the entire column affected in the same way. In a sense, this can function like find and replace in a spreadsheet program. With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  
#find objects of interest and replace with what you want 
Ex: Notice that the values for newborn include `-999.00`. This is sometimes used as a placeholder for NA (but, is a really bad idea). We can use `if_else()` to replace `-999.00` with `NA`.  
```{r}
mammals %>% #Replace values with NA 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
#create new variable newborn_new and if it sees -999.00 it will but a NA if not then it will leave the value alone and not make any changes. 
#you always want to create a new variable so you know how things have changed. 
  arrange(newborn)
```


#Lab 6.2  ; same as HW 6 
The 'janitor' package has the function 'tabyl()' which produces counts and percentages.
**refer to HW for the code for this section**  

#Lab 6 warmup could also be helpful 

#Lab 7.1  
**dplyr Practice Midterm Problem**
```{r}
#use select(), filter(), mutate()
#Build a new dataframe. Have it contain two variables along with a new column. 
```

Tips for Midterm: 
Read the abstract to understand the data. If a piece of code doesn't run put a hashtag in front of it. 
group_by works for categorial variables and it is a way to produce summaries for observations that share an element of interest  
the functions 'summarize' and 'group_by' work well together.  
'count' works when you are only interested in the number of observations (like a combination of groupby and summarize)  
the new package is skimr 
Code involving select(), filter(), mutate()
## `summarize()`
`summarize()` will produce summary statistics for a given variable in a data frame.  
Shortcut to run only a couple lines of code is #Note: shortcut highlight command return  
Ex: If you are asked to calculate the mean of sleep_total for large and small mammals
```{r}
msleep %>% 
  filter(bodywt>200) %>% 
  summarize(mean_sleep_lg = mean(sleep_total))
```

```{r}
msleep %>% 
  filter(bodywt<10) %>% 
  summarize(mean_sleep_sl = mean(sleep_total)) #create a new variable = to mean(sleep_total)
```
**Data found the smaller you are the sleepier you are**
total=n()
This tells the number of observations(rows)
**n_distinct is a function needed for the exam**

`n_distinct()` is a very handy way of cleanly presenting the number of distinct observations.  
There are many other useful summary statistics, depending on your needs: sd(), min(), max(), median(), sum(), n() (returns the length of a column), first() (returns first value in a column), last() (returns last value in a column) and n_distinct() (number of distinct values in a column).  
**group_by = groups together categorical variables before it does the study**

#Lab 7.2 
More groupby and summarize practice. 
`count()` is an easy way of determining how many observations you have within a column. It acts like a combination of `group_by()` and `n()`.  
There is a function in dplyr called `across()` which is designed to work across multiple variables.
If its a factor use levels! 
group_by only works on categorical data.
```{r}
#Load the Data 
#fisheries <- readr::read_csv(file = "data/FAO_1950to2012_111914.csv")
```

What if we are interested in the number of observations (penguins) by species and island?
```{r}
penguins %>% 
  group_by(species, island) %>% 
  summarize(n=n(), .groups= 'keep')#the .groups argument here just prevents a warning message
#the n=n() is the number of observations!
```

across() is a function in dplyr that works across multiple variables. 

What if we wanted to apply `summarize()` in order to produce distinct counts over multiple variables; i.e. species, island, and sex?
```{r}
penguins %>%
  summarize(across(c(species, island, sex), n_distinct)) #variables of interest, ndistinct
```

#Hw 7 (important for more tough problems)
Exploratory analysis of data
Rename columns 
```{r}
#fisheries <- clean_names(fisheries)
#running the janitor library you can perform this function to rename things.
```

Change the data class to a factor 
```{r}
#fisheries$country <- as.factor(fisheries$country)
```

